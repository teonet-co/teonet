/*
 * Copyright (c) 1996-2017 Kirill Scherba <kirill@scherba.ru>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * File:   teonet
 * Author: Kirill Scherba <kirill@scherba.ru>
 *
 * Created on October 18, 2017, 11:03 AM
 *
 * Teonet c++ wrapper
 */

#pragma once

#include <iostream>
#include <string>
#include <vector>
#include <memory>

#include "ev_mgr.h"

namespace teo {

typedef ksnetEvMgrEvents teoEvents;  //! Teonet Events
typedef ksnCorePacketData teoPacket; //! Teonet Packet

/**
 * Teonet class.
 *
 * This is Teonet L0 client C++ wrapper
 */
class Teonet {

public:

    /**
     * Teonet event callback
     */
    typedef void (*teoEventsCb)(Teonet &teo, teoEvents event, void *data,
                         size_t data_len, void *user_data);

private:

    ksnetEvMgrClass *ke;                //! Pointer to ksnetEvMgrClass
    teoEventsCb event_cb;               //! Pointer to c++ callback function
    const char *classVersion = "0.0.2"; //! Teonet class version

public:

    ksnetEvMgrClass * getKe() const {
        return ke;
    }

public:

    /**
     * Teonet constructor
     *
     * Initialize KSNet Event Manager and network and set new default port
     *
     * @param argc Number of applications arguments (from main)
     * @param argv Applications arguments array (from main)
     * @param event_cb Events callback function called when an event happens
     * @param options Options set: \n
     *                READ_OPTIONS - read options from command line parameters; \n
     *                READ_CONFIGURATION - read options from configuration file
     * @param port Set default port number if non 0
     * @param user_data Pointer to user data or NULL if absent
     *
     */
    Teonet(int argc, char** argv,
            teoEventsCb event_cb = NULL,
            int options = READ_ALL,
            int port = 0,
            void *user_data = NULL) {

        this->event_cb = event_cb;
        ke = ksnetEvMgrInitPort(argc, argv, [](ksnetEvMgrClass *ke, teoEvents e,
            void *data, size_t data_len, void *user_data) {
              ((Teonet*) ke->teo_class)->eventCb(e, data, data_len, user_data);
            }, options, port, user_data);
        if(ke) ke->teo_class = this;
    }

    /**
     * Teonet simple destructor
     */
    virtual ~Teonet() { /*std::cout << "Destructor Teonet\n";*/ }

    /**
     * Set Teonet application type
     *
     * @param type Application type string
     */
    inline void setAppType(const char *type) {
        teoSetAppType(ke, (char*)type);
    }

    /**
     * Set Teonet application version
     *
     * @param version Application version string
     */
    inline void setAppVersion(const char *version) {
        teoSetAppVersion(ke, (char*)version);
    }

    /**
     * Start Teonet Event Manager and network communication
     *
     * @return Alway 0
     */
    inline int run() {
        return ksnetEvMgrRun(ke);
    }

    /**
     * Send command by name to peer
     *
     * @param kc Pointer to ksnCoreClass
     * @param to Peer name to send to
     * @param cmd Command
     * @param data Commands data
     * @param data_len Commands data length
     * @return Pointer to ksnet_arp_data or NULL if to peer is absent
     */
    inline ksnet_arp_data *sendTo(const char *to, uint8_t cmd, void *data,
        size_t data_len) {

        return ksnCoreSendCmdto(ke->kc, (char*)to, cmd, data, data_len);
    }

    /**
     * Set custom timer interval
     *
     * @param time_interval
     */
    void setCustomTimer(double time_interval = 2.00) {
        ksnetEvMgrSetCustomTimer(ke, time_interval);
    }

    /**
     * Get this class version
     *
     * @return
     */
    inline const char* getClassVersion() const {
        return classVersion;
    }

    /**
     * Stop Teonet event manager
     *
     */
    inline void stop() {
        ksnetEvMgrStop(ke);
    }

    /**
     * Cast data to teo::teoPacket
     *
     * @param data Pointer to data
     * @return Pointer to teo::teoPacket
     */
    inline teo::teoPacket *getPacket(void *data) const {
        return (teo::teoPacket*) data;
    }

    /**
     * Virtual Teonet event callback
     *
     * @param event
     * @param data
     * @param data_len
     * @param user_data
     */
    virtual inline void eventCb(teo::teoEvents event, void *data,
        size_t data_len, void *user_data) {

        if(event_cb) event_cb(*this, event, data, data_len, user_data);
    };

//};

typedef ksnCQueData cqueData;           //! Teonet CQue data structure
typedef ksnCQueCallback cqueCallback;   //! Teonet CQue callback function

/**
 * Teonet CQue class
 */
class CQue {
    
public:
    
typedef void (*cqueCallback2) (teo::Teonet::CQue &cque, uint32_t id, int type, void *data);    
typedef std::unique_ptr<CQue> CQuePtr;

private:

    Teonet *teo;
    ksnetEvMgrClass *ke;

public:

    CQue(Teonet *t) : teo(t), ke(teo->getKe()) { /*std::cout << "CQue::CQue\n";*/  }
    CQue(const CQue &obj) : teo(obj.teo), ke(obj.ke) { /*std::cout << "CQue::CQue copy\n";*/ }
    virtual ~CQue() { /*std::cout << "~CQue::CQue\n";*/ }

    /**
     * Add callback to queue
     * 
     * @param cb Callback [function](@ref ksnCQueCallback) or NULL. The teonet event 
     *           EV_K_CQUE_CALLBACK should be send at the same time.
     * @param timeout Callback timeout. If equal to 0 than timeout sets automatically
     * @param data The user data which should be send to the Callback function
     * 
     * @return Pointer to added ksnCQueData or NULL if error occurred
     */    
    inline cqueData *add(cqueCallback cb, double timeout = 5.00,
        void *user_data = NULL) {
        return ksnCQueAdd(ke->kq, cb, timeout, user_data);
    }

    cqueData *add(cqueCallback2 cb, double timeout = 5.00,
        void *user_data = NULL) {

        struct UserData {
            CQue *cque;
            cqueCallback2 cb;
            void *user_data;
        };
        
        UserData *ud = new UserData { this, cb, user_data };
        return ksnCQueAdd(ke->kq, [](uint32_t id, int type, void *data) {

            UserData *ud = (UserData *) data;
            ud->cb(*ud->cque, id, type, ud->user_data);
            
            delete(ud);

        }, timeout, ud);
    }

    /**
     * Execute callback queue record 
     * 
     * Execute callback queue record and remove it from queue
     * 
     * @param id Required ID
     * 
     * @return return 0: if callback executed OK; !=0 some error occurred
     */    
    inline int exec(uint32_t id) {
        return ksnCQueExec(ke->kq, id);
    }

    /**
     * Get pointer to CQue data structure
     * 
     * @param data Pointer to data at EV_K_CQUE_CALLBACK event
     * 
     * @return Pointer to CQue data structure 
     */
    inline cqueData *getData(void *data) const {
        return (cqueData *)data;
    }

    /**
     * Get CQue data id
     * 
     * @param cd Pointer to CQue data structure
     * @return CQue id
     */
    inline uint32_t getId(cqueData *cd) const {
        return cd->id;
    }
    
    /**
     * Get pointer to teonet class object
     * 
     * @return Pointer to teonet class object
     */
    inline Teonet* getTeonet() const {
        return teo;
    }
};

/**
 * CQue class factory(maker)
 * 
 * @return Unique pointer to CQue object
 */
inline CQue::CQuePtr getCQueP() {
    return getCQue<std::unique_ptr<teo::Teonet::CQue>>();
}

/**
 * CQue class factory(maker)
 * 
 * @return Reference to CQue object
 */
inline CQue &getCQueR() {
    static auto cque = getCQueP();
    return *cque;
}

/**
 * * CQue class factory(maker)
 * 
 * @return T
 */
template<typename T> T getCQue() {   
    T cque(new CQue(this));
    return cque;
}


};

/**
 * Teonet host info processing class
 */
struct HostInfo {

    std::string name;
    struct {
        std::vector<std::string> v;
        std::string to_string() {
            std::string type_str = "";
            for(auto i = 0; i < v.size(); i++) {
                type_str += v[i] + (i < v.size() - 1 ? ",":"");
            }
            return type_str;
        }
    } type;
    std::string version;
    std::string teonetVersion;

    void makeTeonetVersion(uint8_t *ver, int num_dig = DIG_IN_TEO_VER) {
        teonetVersion = "";
        for(auto i=0; i < num_dig; i++) {
            teonetVersion += std::to_string(ver[i]) +
                    (i < num_dig - 1 ? "." : "");
        }
    }

    HostInfo(void *data) {
        auto host_info = (host_info_data *) data;
        makeTeonetVersion(host_info->ver);
        size_t ptr = 0;
        for(auto i = 0; i <= host_info->string_ar_num; i++)  {
            if(!i) name = host_info->string_ar + ptr;
            else if(i == host_info->string_ar_num) version = host_info->string_ar + ptr;
            else type.v.push_back(host_info->string_ar + ptr);
            ptr += std::char_traits<char>::length(host_info->string_ar + ptr) + 1;
        }
    }
};

}
