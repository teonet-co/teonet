/*
 * Copyright (c) 1996-2017 Kirill Scherba <kirill@scherba.ru>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * File:   teonet
 * Author: Kirill Scherba <kirill@scherba.ru>
 *
 * Created on October 18, 2017, 11:03 AM
 *
 * Teonet c++ wrapper
 */

#pragma once

#include <iostream>
#include <string>
#include <vector>
#include <memory>

#include "ev_mgr.h"
#include "modules/teodb_com.h"

namespace teo {

typedef ksnetEvMgrEvents teoEvents;     //! Teonet Events
typedef ksnCorePacketData teoPacket;    //! Teonet Packet
typedef ksnetEvMgrAppParam teoAppParam; //! Teonet App parameters

/**
 * Teonet class.
 *
 * This is Teonet L0 client C++ wrapper
 */
class Teonet {

public:

    /**
     * Teonet event callback
     */
    typedef void (*teoEventsCb)(Teonet &teo, teoEvents event, void *data,
                         size_t data_len, void *user_data);

private:

    ksnetEvMgrClass *ke;                //! Pointer to ksnetEvMgrClass
    teoEventsCb event_cb;               //! Pointer to c++ callback function
    const char *classVersion = "0.0.2"; //! Teonet class version

public:

    ksnetEvMgrClass * getKe() const {
        return ke;
    }

public:

    /**
     * Teonet constructor
     *
     * Initialize KSNet Event Manager and network and set new default port
     *
     * @param argc Number of applications arguments (from main)
     * @param argv Applications arguments array (from main)
     * @param event_cb Events callback function called when an event happens
     * @param options Options set: \n
     *                READ_OPTIONS - read options from command line parameters; \n
     *                READ_CONFIGURATION - read options from configuration file
     * @param port Set default port number if non 0
     * @param user_data Pointer to user data or NULL if absent
     *
     */
    Teonet(int argc, char** argv,
            teoEventsCb event_cb = NULL,
            int options = READ_ALL,
            int port = 0,
            void *user_data = NULL) {

        this->event_cb = event_cb;
        ke = ksnetEvMgrInitPort(argc, argv, [](ksnetEvMgrClass *ke, teoEvents e,
            void *data, size_t data_len, void *user_data) {
              ((Teonet*) ke->teo_class)->eventCb(e, data, data_len, user_data);
            }, options, port, user_data);
        if(ke) ke->teo_class = this;
    }
    
    /**
     * Teonet simple destructor
     */
    virtual ~Teonet() { /*std::cout << "Destructor Teonet\n";*/ }

    /**
     * Set Teonet application type
     *
     * @param type Application type string
     */
    inline void setAppType(const char *type) {
        teoSetAppType(ke, (char*)type);
    }

    /**
     * Set Teonet application version
     *
     * @param version Application version string
     */
    inline void setAppVersion(const char *version) {
        teoSetAppVersion(ke, (char*)version);
    }

    /**
     * Start Teonet Event Manager and network communication
     *
     * @return Alway 0
     */
    inline int run() {
        return ksnetEvMgrRun(ke);
    }

    /**
     * Send command by name to peer
     *
     * @param kc Pointer to ksnCoreClass
     * @param to Peer name to send to
     * @param cmd Command
     * @param data Commands data
     * @param data_len Commands data length
     * @return Pointer to ksnet_arp_data or NULL if to peer is absent
     */
    inline ksnet_arp_data *sendTo(const char *to, uint8_t cmd, void *data,
        size_t data_len) {

        return ksnCoreSendCmdto(ke->kc, (char*)to, cmd, data, data_len);
    }

    /**
     * Set custom timer interval
     *
     * @param time_interval
     */
    void setCustomTimer(double time_interval = 2.00) {
        ksnetEvMgrSetCustomTimer(ke, time_interval);
    }

    /**
     * Get this class version
     *
     * @return
     */
    inline const char* getClassVersion() const {
        return classVersion;
    }

    /**
     * Stop Teonet event manager
     *
     */
    inline void stop() {
        ksnetEvMgrStop(ke);
    }

    /**
     * Cast data to teo::teoPacket
     *
     * @param data Pointer to data
     * @return Pointer to teo::teoPacket
     */
    inline teo::teoPacket *getPacket(void *data) const {
        return (teo::teoPacket*) data;
    }

    /**
     * Virtual Teonet event callback
     *
     * @param event
     * @param data
     * @param data_len
     * @param user_data
     */
    virtual inline void eventCb(teo::teoEvents event, void *data,
        size_t data_len, void *user_data) {

        if(event_cb) event_cb(*this, event, data, data_len, user_data);
    };

//};

typedef ksnCQueData cqueData;           //! Teonet CQue data structure
typedef ksnCQueCallback cqueCallback;   //! Teonet CQue callback function

/**
 * Teonet CQue class
 */
class CQue {
    
public:
    
typedef void (*cqueCallback2) (teo::Teonet::CQue &cque, uint32_t id, int type, void *data);    
typedef std::unique_ptr<CQue> cquePtr;

private:

    Teonet *teo;
    ksnetEvMgrClass *ke;

public:

    CQue(Teonet *t) : teo(t), ke(teo->getKe()) { /*std::cout << "CQue::CQue\n";*/  }
    CQue(const CQue &obj) : teo(obj.teo), ke(obj.ke) { /*std::cout << "CQue::CQue copy\n";*/ }
    virtual ~CQue() { /*std::cout << "~CQue::CQue\n";*/ }

    /**
     * Add callback to queue
     * 
     * @param cb Callback [function](@ref ksnCQueCallback) or NULL. The teonet event 
     *           EV_K_CQUE_CALLBACK should be send at the same time.
     * @param timeout Callback timeout. If equal to 0 than timeout sets automatically
     * @param data The user data which should be send to the Callback function
     * 
     * @return Pointer to added ksnCQueData or NULL if error occurred
     */    
    inline cqueData *add(cqueCallback cb, double timeout = 5.00,
        void *user_data = NULL) {
        return ksnCQueAdd(ke->kq, cb, timeout, user_data);
    }

    cqueData *add(cqueCallback2 cb, double timeout = 5.00,
        void *user_data = NULL) {

        struct UserData {
            CQue *cque;
            cqueCallback2 cb;
            void *user_data;
        };
        
        UserData *ud = new UserData { this, cb, user_data };
        return ksnCQueAdd(ke->kq, [](uint32_t id, int type, void *data) {

            UserData *ud = (UserData *) data;
            ud->cb(*ud->cque, id, type, ud->user_data);
            
            delete(ud);

        }, timeout, ud);
    }

    /**
     * Execute callback queue record 
     * 
     * Execute callback queue record and remove it from queue
     * 
     * @param id Required ID
     * 
     * @return return 0: if callback executed OK; !=0 some error occurred
     */    
    inline int exec(uint32_t id) {
        return ksnCQueExec(ke->kq, id);
    }

    /**
     * Get pointer to CQue data structure
     * 
     * @param data Pointer to data at EV_K_CQUE_CALLBACK event
     * 
     * @return Pointer to CQue data structure 
     */
    inline cqueData *getData(void *data) const {
        return (cqueData *)data;
    }

    /**
     * Get CQue data id
     * 
     * @param cd Pointer to CQue data structure
     * @return CQue id
     */
    inline uint32_t getId(cqueData *cd) const {
        return cd->id;
    }
    
    /**
     * Get pointer to teonet class object
     * 
     * @return Pointer to teonet class object
     */
    inline Teonet* getTeonet() const {
        return teo;
    }
};

/**
 * CQue class factory(maker)
 * 
 * @return Unique pointer to CQue object
 */
inline CQue::cquePtr getCQueP() {
    return getCQue<std::unique_ptr<teo::Teonet::CQue>>();
}

/**
 * CQue class factory(maker)
 * 
 * @return Reference to CQue object
 */
inline CQue &getCQueR() {
    static auto cque = getCQueP();
    return *cque;
}

/**
 * CQue class factory(maker)
 * 
 * @return T
 */
template<typename T> T getCQue() {   
    T cque(new CQue(this));
    return cque;
}

class TeoDB {
    
public:    
    
    typedef teo_db_data teoDbData;
    typedef teo_db_data_range teoDbDataRange;
    typedef struct teoDbCQueData {

        TeoDB *teoDb;
        teoDbData **tdd;

        teoDbCQueData(TeoDB *teoDb, teoDbData **tdd) : teoDb(teoDb), tdd(tdd) {}
        
        inline void *getKey() const {
            return (*tdd)->key_data;
        }
        inline char *getKeyStr() const {
            return (char*) getKey();
        }
        
        inline void *getValue() const {
            return (*tdd)->key_data + (*tdd)->key_length;
        }
        inline char *getValueStr() const {
            return (char*) getValue();
        }

    } teoDbCQueData;
    
private:

    Teonet *teo;
    teoDbData **tdd;
    std::string peer;
    CQue cque = CQue(teo);

public:

    TeoDB(Teonet *t, const std::string peer, teoDbData **tdd) : teo(t), tdd(tdd), peer(peer) { /*std::cout << "TeoDB::TeoDB\n";*/  }
    TeoDB(const TeoDB &obj) : teo(obj.teo), tdd(obj.tdd), peer(obj.peer) { /*std::cout << "TeoDB::TeoDB copy\n";*/ }
    virtual ~TeoDB() { /*std::cout << "~TeoDB::TeoDB\n";*/ }
    
    /**
     * Get pointer to teonet class object
     * 
     * @return Pointer to teonet class object
     */
    inline Teonet* getTeonet() const {
        return teo;
    }
    
    inline const char* getPeer() const {
        return peer.c_str();
    }
    
    inline bool checkPeer(const char *peer_name) {
        return !strcmp(peer.c_str(), peer_name);
    }

    inline std::unique_ptr<teoDbData> prepareRequest(const void *key, size_t key_len,
        const void *data, size_t data_len, uint32_t id, size_t *tdd_len)    {
        
        return (std::unique_ptr<teoDbData>) prepare_request_data(key, key_len, data, data_len, id, tdd_len);
    }
    
    static inline teoDbData* getData(teo::teoPacket *rd) {
        return (teoDbData*) (rd ? rd->data : NULL);
    }

    ksnet_arp_data *send(uint8_t cmd, const void *key, size_t key_len, 
        const void *data, size_t data_len) {
        return _send(cmd, key, key_len, data, data_len);
    }
    
    ksnet_arp_data *send(uint8_t cmd, const void *key, size_t key_len,
        cqueCallback cb = NULL, double timeout = 5.00, teoDbData **tdd = NULL, void *user_data = NULL) {
        return _send(cmd, key, key_len, NULL, 0, cb, timeout, tdd, user_data);
    }
    
    inline int  exec(uint32_t id) {
        return cque.exec(id);
    }
    
    bool process(teoEvents event, void *data) {
        
        bool processed = false;
        auto rd = teo->getPacket(data);
        auto tdd = getData(rd);
        
        // Check teonet event
        switch(event) {
            
            case EV_K_RECEIVED:
        
                // DATA event            
                if(rd && checkPeer(rd->from)) {
                    
                    switch(rd->cmd) {
                        
                        // Get data response #132
                        case CMD_D_GET_ANSWER: 
                        // Get list response #133
                        case CMD_D_LIST_ANSWER: 
                            
                            if(tdd && tdd->id && !exec(tdd->id)) processed = true;
                            break;
                    }
                }
                break;
                
            default:
                break;
        }
            
        return processed;    
    }
    
private:
    
    ksnet_arp_data *_send(uint8_t cmd, const void *key, size_t key_len, 
        const void *data = NULL, size_t data_len = 0, 
        cqueCallback cb = NULL, double timeout = 5.00, teoDbData **tdd = NULL, void *user_data = NULL) {
        
        uint32_t id = 0;
        
        // Add callback to queue and wait timeout after 5 sec ...
        if(cb) {
            if(!user_data) {
                // Add callback to queue and wait timeout after 5 sec ...
                if(!tdd) tdd = this->tdd;
                user_data = new teoDbCQueData(this, tdd);
            }
            auto cq = cque.add(cb, timeout, user_data);
            std::cout << "... Register callback id " << cq->id << "\n";
            id = cq->id;
        }
        
        size_t tdd_len;
        auto tddr = prepareRequest(key, key_len, data, data_len, id, &tdd_len);
        //auto tddr = prepare_request_data(key, key_len, data, data_len, id, &tdd_len);
        return teo->sendTo(peer.c_str(), cmd, tddr.get(), tdd_len);
    }        
};

};

/**
 * Teonet host info processing class
 */
struct HostInfo {
    

    std::string name;
    struct {
        std::vector<std::string> v;
        std::string to_string() {
            std::string type_str = "";
            for(size_t i = 0; i < v.size(); i++) {
                type_str += v[i] + (i < v.size() - 1 ? ",":"");
            }
            return type_str;
        }
    } type;
    std::string version;
    std::string teonetVersion;

    void makeTeonetVersion(uint8_t *ver, int num_dig = DIG_IN_TEO_VER) {
        teonetVersion = "";
        for(auto i=0; i < num_dig; i++) {
            teonetVersion += std::to_string(ver[i]) +
                    (i < num_dig - 1 ? "." : "");
        }
    }

    HostInfo(void *data) {
        auto host_info = (host_info_data *) data;
        makeTeonetVersion(host_info->ver);
        size_t ptr = 0;
        for(auto i = 0; i <= host_info->string_ar_num; i++)  {
            if(!i) name = host_info->string_ar + ptr;
            else if(i == host_info->string_ar_num) version = host_info->string_ar + ptr;
            else type.v.push_back(host_info->string_ar + ptr);
            ptr += std::char_traits<char>::length(host_info->string_ar + ptr) + 1;
        }
    }
};

}
