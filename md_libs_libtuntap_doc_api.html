<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Teonet library: API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Teonet library
   &#160;<span id="projectnumber">0.4.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_libs_libtuntap_doc_api.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Types </h1>
<h2>struct device </h2>
<p>The <code>struct device</code> is an opaque structure containing internal parameter, like the device name, device flags, device file descriptor, etc. You should not access them.</p>
<p>The structure size may vary from an operating system to an other, you should not rely on it.</p>
<h2>t_tuntap_log </h2>
<pre class="fragment">typedef void (*t_tuntap_log)(int level, const char *msg);
</pre><p>This type is a pointer to a log function. It allows to override the default behaviour, which is printing every messages on the error output prefixed with its error level.</p>
<p>Error levels are described later, they are macros in the form <code>TUNTAP_LOG_*</code>.</p>
<h2>t_tun </h2>
<p>The <code>t_tun</code> type map the file descriptor type of a given operating system.</p>
<p>Typically it's an <code>int</code> on UNIXes and a <code>HANDLE</code> on Windows.</p>
<h1>Macros </h1>
<p>There is two type of macros, the libtuntap ones, and the "portable" ones. The laters are here to help portable parts of the code to rely on meaningful names, not hard-coded magic values.</p>
<h2>libtuntap macros </h2>
<h2>TUNTAP_ID_MAX </h2>
<p><code>TUNTAP_ID_MAX</code> is the maximal device unit giveable as the third parameter of <code><a class="el" href="tuntap-unix_8c.html#a57d9b16831b7d77babe7fdc04ac10008">tuntap_start()</a></code>.</p>
<h2>TUNTAP_ID_ANY </h2>
<p><code>TUNTAP_ID_ANY</code> is the wild-card device unit giveable as the third parameter of <code><a class="el" href="tuntap-unix_8c.html#a57d9b16831b7d77babe7fdc04ac10008">tuntap_start()</a></code>.</p>
<h2>TUNTAP_MODE_ETHERNET </h2>
<p><code>TUNTAP_MODE_ETHERNET</code> is the tap-mode giveable as the second parameter of <code><a class="el" href="tuntap-unix_8c.html#a57d9b16831b7d77babe7fdc04ac10008">tuntap_start()</a></code>.</p>
<h2>TUNTAP_MODE_TUNNEL </h2>
<p><code>TUNTAP_MODE_TUNNEL</code> is the tun-mode giveable as the second parameter of <code><a class="el" href="tuntap-unix_8c.html#a57d9b16831b7d77babe7fdc04ac10008">tuntap_start()</a></code>.</p>
<h2>TUNTAP_MODE_PERSIST </h2>
<p><code>TUNTAP_MODE_PERSIST</code> is the persistence flag giveable OR'ed with the second parameter of <code><a class="el" href="tuntap-unix_8c.html#a57d9b16831b7d77babe7fdc04ac10008">tuntap_start()</a></code>.</p>
<p>This flag is optional and should be used with either <code>TUNTAP_MODE_TUNNEL</code> or <code>TUNTAP_MODE_ETHERNET</code>.</p>
<h2>TUNTAP_LOG_ERR </h2>
<p><code>TUNTAP_LOG_ERR</code> describes an error message.</p>
<h2>TUNTAP_LOG_WARN </h2>
<p><code>TUNTAP_LOG_WARN</code> describes a warning message.</p>
<h2>TUNTAP_LOG_INFO </h2>
<p><code>TUNTAP_LOG_INFO</code> describes an informational message.</p>
<h2>TUNTAP_LOG_NOTICE </h2>
<p><code>TUNTAP_LOG_NOTICE</code> describes a message which is not really an error nor a warning. It is mostly used to warn about unimplemented or unavailable part of the libtuntap.</p>
<h2>TUNTAP_LOG_DEBUG </h2>
<p><code>TUNTAP_LOG_DEBUG</code> describes a debug messages. You should see one only if your are using the git HEAD.</p>
<h2>TUNTAP_LOG_NONE </h2>
<p><code>TUNTAP_LOG_NONE</code> describes other things. It is only used by <code><a class="el" href="tuntap_8h.html#aadcec46de8ac8adb9b5e56e354d5c01f">tuntap_log_hexdump()</a></code> and <code><a class="el" href="tuntap_8h.html#a2616a2dd4ce99ec786d48f06115c459f">tuntap_log_chksum()</a></code>.</p>
<h2>Portable macros </h2>
<h2>ETHER_ADDR_LEN </h2>
<p><code>ETHER_ADDR_LEN</code> is a value dictated by [[<a href="http://www.ieee802.org/3/">http://www.ieee802.org/3/</a>|IEEE 802.3]] standard. On Linux systems its value is mapped on <code>ETH_ALEN</code> one.</p>
<h2>IF_NAMESIZE </h2>
<p><code>IF_NAMESIZE</code> gives the maximal length of an interface name. On BSD systems its value is mapped on <code>IFNAMSIZ</code> one.</p>
<h2>IF_DESCRSIZE </h2>
<p><code>IF_DESCSIZE</code> gives the maximal length of an interface description.</p>
<h2>TUNFD_INVALID_VALUE </h2>
<p><code>TUNFD_INVALID_VALUE</code> is the invalid value of the t_tun type. On UNIXes systems its value is <code>-1</code>. On Windows systems its value is <code>INVALID_HANDLE_VALUE</code>.</p>
<h1>Functions </h1>
<h2>tuntap_init </h2>
<pre class="fragment">struct device *tuntap_init(void);
</pre><p>This function will allocate and initialise a <code>struct device</code>.</p>
<h2>tuntap_version </h2>
<pre class="fragment">int tuntap_version(void);
</pre><p>This function returns the version number of libtuntap. You can extract the major and the minor like this: </p>
<pre class="fragment">int version = tuntap_version();
int major = version &gt;&gt; 8;
int minor = version &amp; major;
</pre><p>Note that this version number is not the same as the shared library version.</p>
<h2>tuntap_destroy </h2>
<pre class="fragment">void tuntap_destroy(struct device *dev);
</pre><p>This function will free allocated memory, close file descriptors and destroy the interface.</p>
<p>=== tuntap_release </p>
<pre class="fragment">void tuntap_release(struct device *dev);
</pre><p>This function will free allocated memory and close file descriptors. leaving the interface.</p>
<p>=== tuntap_start </p>
<pre class="fragment">int tuntap_start(struct device dev*, int mode, int unit);
</pre><p>This function will configure the device with the mode <code>mode</code> and the optional device unit <code>unit</code>.</p>
<p>The <code>mode</code> parameter should be either <code>TUNTAP_MODE_ETHERNET</code> or <code>TUNTAP_MODE_TUNNEL</code> eventually ORed with <code>TUNTAP_MODE_PERSIST</code>.</p>
<p>The <code>unit</code> parameter should always be less than <code>TUNTAP_ID_MAX</code> and greater than 0. If you don't need a particular value, you should use <code>TUNTAP_ID_ANY</code>, which is a sort of wild-card device unit. With this parameter, the kernel will pick the next available device. The term "device unit" is also known as PPA, for Physical Point of Attachment, in Solaris documentation.</p>
<p>Examples: </p>
<pre class="fragment">tuntap_start(dev, TUNTAP_MODE_ETHERNET, TUNTAP_ID_ANY)

tuntap_start(dev, TUNTAP_MODE_TUNNEL, 2)

tuntap_start(dev, TUNTAP_MODE_TUNNEL | TUNTAP_MODE_PERSIST, TUNTAP_ID_ANY)
</pre><h2>tuntap_get_ifname </h2>
<pre class="fragment">char     *tuntap_get_ifname(struct device *dev);
</pre><p>This function fetch and return the name of the interface described by <code>dev</code>.</p>
<h2>tuntap_set_ifname </h2>
<pre class="fragment">int tuntap_set_ifname(struct device *dev, const char *ifname);
</pre><p>This function replaces the name of the interface described by <code>dev</code> with the given name <code>ifname</code>.</p>
<p>It returns -1 on error.</p>
<p>Compatibility: Linux.</p>
<h2>tuntap_get_hwaddr </h2>
<pre class="fragment">char         *tuntap_get_hwaddr(struct device *dev);
</pre><p>This function fetch and returns the link-layer address (MAC) of the interface described by <code>dev</code>.</p>
<p>The returned string come from a statically allocated buffer, ans thus should be saved if needed for later use.</p>
<h2>tuntap_set_hwaddr </h2>
<pre class="fragment">int tuntap_set_hwaddr(struct device *dev, const char *mac_addr);
</pre><p>This function replaces the link-layer address of the interface described by <code>dev</code> with the given address <code>mac_addr</code>.</p>
<p>It returns -1 on error.</p>
<h2>tuntap_set_descr </h2>
<pre class="fragment">int tuntap_set_descr(struct device *dev, const char *desc);
</pre><p>This function replaces the description of the interface described by <code>dev</code> with the given string <code>desc</code>.</p>
<p>Compatibility: OpenBSD, FreeBSD.</p>
<h2>tuntap_up </h2>
<pre class="fragment">int tuntap_up(struct device *dev);
</pre><p>This function set interface to the UP state, just like <code>ifconfig eth0 up</code> would do.</p>
<h2>tuntap_down </h2>
<pre class="fragment">int tuntap_down(struct device *dev);
</pre><p>This function set interface to the DOWN state, just like <code>ifconfig eth0 down</code> would do.</p>
<h2>tuntap_get_mtu </h2>
<pre class="fragment">int tuntap_get_mtu(struct device *dev);
</pre><p>This function fetch and returns the Maximum Transfer Unit (MTU) of the interface described by <code>dev</code>.</p>
<h2>tuntap_set_mtu </h2>
<pre class="fragment">int tuntap_set_mtu(struct device *dev, int mtu);
</pre><p>This function replaces the MTU of the interface described by <code>dev</code> with the given value <code>mtu</code>.</p>
<h2>tuntap_set_ip </h2>
<pre class="fragment">int tuntap_set_ip(struct device *dev, const char *, int ip_addr);
</pre><p>This function replaces the IP address of the interface described by <code>dev</code> with the given address <code>ip_addr</code>.</p>
<h2>tuntap_read </h2>
<pre class="fragment">int tuntap_read(struct device *dev, void *buf, size_t buf_len);
</pre><p>This function will read one packet from the interface descibed by <code>dev</code> and will store it in the buffer <code>buf</code> of size <code>buf_len</code>. This value can be retrieved with a call to <code><a class="el" href="tuntap-unix_8c.html#ae25335c60a5d438a4800a4f060917b71">tuntap_get_readable()</a></code>.</p>
<h2>tuntap_write </h2>
<pre class="fragment">int tuntap_write(struct device *dev, void *buf, size_t buf_len);
</pre><p>This function will write the packet stored in the buffer <code>buf</code> of size <code>buf_len</code> to the interface descibed by <code>dev</code>.</p>
<h2>tuntap_get_readable </h2>
<pre class="fragment">int tuntap_get_readable(struct device *dev);
</pre><p>This function will return the size of the next packet waiting in the buffer queue of the interface described by <code>dev</code>. On Linux this function is the same as <code><a class="el" href="tuntap-unix_8c.html#a2ea30bbb23a56e2491bc910879d0b9b7">tuntap_get_mtu()</a></code>, because the ioctl call <code>FIONREAD</code> is not supported on caracter devices.</p>
<h2>tuntap_set_nonblocking </h2>
<pre class="fragment">int tuntap_set_nonblocking(struct device *dev, int set);
</pre><p>This function will set the socket of the interface described by <code>dev</code> to a non-blocking state.</p>
<h2>tuntap_set_debug </h2>
<pre class="fragment">int tuntap_set_debug(struct device *dev, int set);
</pre><p>This function will enable or disable the debug mode of the interface described by <code>dev</code>, depending of the value of <code>set</code>.</p>
<p>If <code>set</code> is 0, it will disable debug, and if it is 1 it will enable it.</p>
<p>The debug mode will add more output regarding the interface on the console.</p>
<p>This functionality depend on your operating system. It is enable by default on FreeBSD and NetBSD, but you might have to recompile your tun and tap drivers on Linux and OpenBSD to enable it.</p>
<h2>tuntap_log_set_cb </h2>
<pre class="fragment">void tuntap_log_set_cb(t_tuntap_log cb);
</pre><p>This function allow to set an external printing function, in order to erase the default behaviour.</p>
<h2>tuntap_log_hexdump </h2>
<pre class="fragment">void tuntap_log_hexdump(void *, size_t);
</pre><p>This function is actualy not documented.</p>
<h2>tuntap_log_chksum </h2>
<pre class="fragment">void tuntap_log_chksum(void *, int);
</pre><p>This function is actualy not documented.</p>
<h2>TUNTAP_GET_FD </h2>
<pre class="fragment">int TUNTAP_GET_FD(struct device *dev)
</pre><p>This macro will return the socket of the interface described by <code>dev</code>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Apr 13 2021 12:51:56 for Teonet library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
